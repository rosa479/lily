<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Slides</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/dracula.css">
        <link rel="stylesheet" href="dist/custom.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section>
                    <h2>Interpreting Compilers and Compiling Interpreters</h2>
                    <p>By yours truly</p>
                </section>
                <section class="no-auto-fragments">
                    Consider this C++ snippet
                    <pre><code class="language-cpp" data-line-numbers="2">int main() {
    return 57;
}
                    </code></pre>
                    Let's compile this and execute it
                    <pre><code class="language-bash" data-line-numbers="1-2|3-4">$ g++ -o hello hello.cpp
$ ./hello
$ echo $? # shows return value of last command
  57
                    </code></pre>
                </section>
                <section>
                    <p>How did our code in "English" turn into 0s and 1s?</p>
                    <p class="fragment fade-in">What happened in between?</p>
                    <p class="fragment fade-in">What does it mean to <b>compile?</b></p>
                </section>
                <section>
                    <p>In simple terms, a Compiler is a translater, that takes code written in a high-level language (return blablabla) and converts it into a low-level language that a computer can understand (01010101...)</p>
                    <p class="fragment fade-in">This is a one-time process, and the output is a file that can be executed multiple times</p>
                    <p class="fragment fade-in">But this isn't the only translator in the market</p>
                    <p class="fragment fade-in">Enter the <b>Interpreter</b></p>
                </section>
                <section>
                    <p>Instead of translating the entire code at once, an Interpreter translates the code line-by-line, executing it as it goes</p>
                    <p class="fragment fade-in">with some trade-offs...</p>
                </section>
<section>
    <h2>Compiler vs. Interpreter</h2>
        <table style="font-size: 0.9em;">
        <thead>
            <tr>
                <th>Compiler</th>
                <th>Interpreter</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Compiles the whole code before execution</td>
                <td>Executes code line-by-line</td>
            </tr>
            <tr>
                <td>Faster execution</td>
                <td>Slower execution</td>
            </tr>
            <tr>
                <td>Displays all errors after compilation</td>
                <td>Stops at the first error</td>
            </tr>
            <tr>
                <td>No source code needed after compilation</td>
                <td>Requires source code every time</td>
            </tr>
            <tr>
                <td>Used in production (C, C++, C#)</td>
                <td>Used in development (Python, Ruby, Perl)</td>
            </tr>
        </tbody>
    </table>
</section>

<!-- Compilation Flow Slide -->
<section>
    <h2 class="fragment fade-in move-up" data-fragment-index="0">Compilation Flow</h2>
    <ol style="font-size: 0.8em;">
        <li class="fragment fade-in" data-fragment-index="1"><strong>Lexing</strong> – Convert code into tokens.</li>
        <li class="fragment fade-in" data-fragment-index="2"><strong>Parsing</strong> – Generate AST.</li>
        <li class="fragment fade-in" data-fragment-index="3"><strong>Semantic Analysis</strong> – Check correctness.</li>
        <li class="fragment fade-in" data-fragment-index="4"><strong>IR Generation</strong> – Convert AST to IR.</li>
        <li class="fragment fade-in" data-fragment-index="5"><strong>Optimization</strong> – Improve performance.</li>
        <li class="fragment fade-in" data-fragment-index="6"><strong>Code Generation</strong> – Convert IR to assembly.</li>
        <li class="fragment fade-in" data-fragment-index="7"><strong>Assembly to Machine Code</strong>:
            <ul>
                <li><strong>Assembler</strong> – Assembly → Object code.</li>
                <li><strong>Linker</strong> – Creates executable.</li>
            </ul>
        </li>
        <li class="fragment fade-in" data-fragment-index="8"><strong>Execution</strong> – CPU runs machine code.</li>
    </ol>
</section>

<!-- Interpretation Flow Slide -->
<section>
    <h2 class="fragment fade-in move-up" data-fragment-index="0">Interpretation Flow</h2>
    <ol style="font-size: 0.8em;">
        <li class="fragment fade-in" data-fragment-index="1"><strong>Lexing</strong> – Convert code into tokens.</li>
        <li class="fragment fade-in" data-fragment-index="2"><strong>Parsing</strong> – Generate AST.</li>
        <li class="fragment fade-in" data-fragment-index="3"><strong>Semantic Analysis</strong> – Check correctness.</li>
        <li class="fragment fade-in" data-fragment-index="4"><strong>Execution</strong>:
            <ul>
                <li><strong>Interpreter</strong> – Executes code line by line.</li>
                <li><strong>Bytecode</strong> – Runs on VM (e.g., CPython, JVM).</li>
                <li><strong>JIT</strong> – Converts hot code to machine code.</li>
            </ul>
        </li>
    </ol>
</section>

                
<section>
<h1>Compilers</h1>
</section>

                <section>
                    <p style="font-size:0.8em">Compiler converts the code into assembly language, which is then converted into machine code by the assembler
                    <br>What does the assembly code for our C++ program look like?
                        We can run the following command to get the assembly code</p>
                    <pre><code class="language-bash">g++ -S -o hello.s hello.cpp</code></pre>
    <div style="display: flex; gap: 20px;">
        <div style="width: 50%;">
            <h5>C++ Code</h5>
            <pre><code class="language-cpp" data-trim data-line-numbers>int main() {
    return 57;
}</code></pre>
        </div>
        <div style="width: 50%;">
            <h5>Assembly</h5>
            <pre><code class="x86asm" data-line-numbers>	.file	"hello.cpp"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	endbr64
	; and so on...
            </code></pre>
        </div>
    </div>

                </section>
                <section>
                <h2> A brief look at assembly </h2>
                    <section>
                        <p>Assembly language is a low-level programming language that is a human-readable version of machine code</p>
                        <p class="fragment fade-in">It uses mnemonics to represent machine instructions (like <b>MOV</b>, <b>ADD</b>, <b>SUB</b>)</p>
                        <p class="fragment fade-in">It requires manual handling of CPU registers and memory addresses </p>
                    </section>
                    <section>
                        Each assembly language only works for a specific CPU architecture
                        <p class="fragment fade-in">x86-64 for Intel</p>
                        <p class="fragment fade-in">ARM for Apple M-series</p>
                    </section>
                    <section>
                        Compilers must generate assembly code that is compatible with the target architecture and OS
                        <p class="fragment fade-in">g++ will give a.out in Linux, a.exe in Windows</p>
                        <p class="fragment fade-in">Each OS has different syscalls(?)</p>
                        <p class="fragment fade-in">Headers change, from &lt;windows.h&gt; to &lt;unistd.h&gt;</p>
                        <p class="fragment fade-in">and so do file system conventions, from "C:\\Users\\" to "/home/user/"</p>
                    </section>
                    <section style="font-size: 0.9em;">
                        <p>Data can be stored in memory and can be accessed using memory addresses</p>
                        <p class="fragment fade-in">Reading and storing data in this way is slow</p>
                        <p class="fragment fade-in">A much faster alternative are <b>registers</b> which are internal storage locations of the processor</p>
                        <p class="fragment fade-in">Registers are the processor's personal notepad for storing information temporarily, though few in number</p>
                        <p class="fragment fade-in">Examples - <b>RAX</b>, <b>ESP</b>, <b>DS</b></p>
                    </section>

                    <section style="font-size: 0.9em;">
                        <p><b>System Calls</b> are APIs for the interface between the user space and the kernel space</p>
                        <p class="fragment fade-in">Every system call has a unique number associated with it</p>
                        <p class="fragment fade-in">This number is stored in the <b>EAX</b> or <b>RAX</b> with arguments passed to other general purpose registers and stack as needed</p>
                        <p class="fragment fade-in">The <b>syscall</b> instruction is used to trigger a system call</p>
                    </section>
                
                    <section class="no-auto-fragments">
                        <p>Let's take a look at the (simplified) assembly equivalent of our C++ snippet<p>
                            <pre><code class="x86asm"  data-line-numbers>global _start
_start:
   mov rax, 60
   mov rdi, 57
   syscall
            </code></pre>

                    </section>
                    <section class="no-auto-fragments">
                        <p>This tells the assembler to expose <b>_start</b> as the global label so that the linker can recognise it as the entry point of the program<p>
                            <pre><code class="x86asm"  data-line-numbers="1">global _start
_start:
   mov rax, 60
   mov rdi, 57
   syscall
            </code></pre>

                    </section>
                    <section class="no-auto-fragments">
                        <p>This defines the <b>_start</b> label, which is the entry point of our program<p>
                            <pre><code class="x86asm"  data-line-numbers="2">global _start
_start:
   mov rax, 60
   mov rdi, 57
   syscall
            </code></pre>

                    </section>

                    <section class="no-auto-fragments">
                        <p>Moves the value <b>60</b> into the register <b>rax</b><p>
                        <p>In Linux x86-64, <b>60</b> is the syscall number for <b>exit</b></p>
                            <pre><code class="x86asm"  data-line-numbers="3">global _start
_start:
   mov rax, 60
   mov rdi, 57
   syscall
            </code></pre>

                    </section>

                    <section class="no-auto-fragments">
                        <p>Moves the value <b>57</b> into the register <b>rdi</b><p>
                        <p>The <b>exit</b> syscall uses <b>rdi</b> as its first argument, which represent the exit status of the program</p>
                            <pre><code class="x86asm"  data-line-numbers="4">global _start
_start:
   mov rax, 60
   mov rdi, 57
   syscall
            </code></pre>

                    </section>

                    <section class="no-auto-fragments">
                        <p>Triggers a system call. Since <b>rax</b> contains 60, this executes <b>exit(57)</b> syscall, terminating the program with exit code <b>57</b><p>
                            <pre><code class="x86asm"  data-line-numbers="5">global _start
_start:
   mov rax, 60
   mov rdi, 57
   syscall
            </code></pre>

                    </section>
                    <section>
                        <p>Let's compile and run this assembly code</p>
                        <div class="fragment fade-in"><p>The assembler, <b>nasm</b>, translated the assembly code into machine code and generates and object file</p>
                        <pre><code class="bash">nasm -f elf64 -o hello.o hello.s</code></pre></div>
                        <div class="fragment fade-in">
                            <p>The linker, <b>ld</b> takes the object file and links it with the necessary library to create an executable file</p>
                            <pre><code class="bash">ld -o hello hello.o</code></pre></div>
                    </section>
                    <section>Questions about how the variables are stored in memory, how mathematical operations happens still remain unanswered, but we will get back to them!</section>
                </section>
                <section>
                    Compiler
                </section>

            </div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>

<script>
    class RevealAutoFragment {
        constructor(delayBetweenFragments = 1000, exceptionClass = "no-auto-fragments") {
            this.delayBetweenFragments = delayBetweenFragments;
            this.exceptionClass = exceptionClass;
            this.init();
        }

        init() {
            Reveal.on('slidechanged', event => this.handleSlideChange(event));
        }

        handleSlideChange(event) {
            if (event.currentSlide.classList.contains(this.exceptionClass)) {
                return; // Skip this slide if it has the exception class
            }

            let fragments = event.currentSlide.querySelectorAll('.fragment');
            let delay = 500; // Initial delay before first fragment appears

            fragments.forEach(fragment => {
                setTimeout(() => {
                    fragment.classList.add('visible');
                }, delay);
                delay += this.delayBetweenFragments;
            });
        }
    }

    Reveal.initialize({
        hash: true,
        autoPlayMedia: true,
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });

    new RevealAutoFragment(500, "no-auto-fragments"); // Exclude slides with this class
</script>

	</body>
</html>
